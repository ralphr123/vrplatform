// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import { DefaultAzureCredential } from "@azure/identity";
import {
  AzureMediaServices,
  BuiltInStandardEncoderPreset,
  JobOutputAsset,
  JobInputUnion,
  JobsGetResponse,
} from "@azure/arm-mediaservices";
import * as factory from "./transformFactory";
import { v4 as uuidv4 } from "uuid";
import * as util from "util";
import { ApiReturnType } from "../types/api";
import {
  BlobSASPermissions,
  BlobServiceClient,
  generateBlobSASQueryParameters,
  StorageSharedKeyCredential,
} from "@azure/storage-blob";

let mediaServicesClient: AzureMediaServices;
let blobServicesClient: BlobServiceClient;

const {
  AZURE_SUBSCRIPTION_ID: subscriptionId,
  AZURE_RESOURCE_GROUP: resourceGroupName,
  AZURE_MEDIA_SERVICES_ACCOUNT_NAME: mediaServicesAccountName,
  AZURE_STORAGE_ACCOUNT_NAME: blobServicesAccountName,
  AZURE_STORAGE_ACCOUNT_KEY: blobServicesAccountKey,
} = process.env;

const credential = new DefaultAzureCredential();
const storageUrl = `https://${mediaServicesAccountName}.blob.core.windows.net`;

// Timer values
const TIMEOUT_SECONDS = 60 * 10;
const SLEEP_INTERVAL = 1000 * 2;
const setTimeoutPromise = util.promisify(setTimeout);

// Args
const NAME_PREFIX = "stream";

export type EncodeVideoOnAzureFromBlobResp = {
  streamingUrls: string[];
  thumbnailUrl: string;
};

export const encodeVideoOnAzureFromBlob = async (
  blobUrl: string
): Promise<ApiReturnType<EncodeVideoOnAzureFromBlobResp>> => {
  // Define the name to use for the encoding Transform that will be created
  const encodingTransformName = "ContentAwareEncoding";

  mediaServicesClient = new AzureMediaServices(credential, subscriptionId);
  blobServicesClient = new BlobServiceClient(storageUrl, credential);

  try {
    const uniqueness = uuidv4();
    const input = await getJobInputType({ blobUrl, uniqueness });
    const outputAssetName = `${NAME_PREFIX}-output-${uniqueness}`;
    const jobName = `${NAME_PREFIX}-job-${uniqueness}`;
    const locatorName = `locator${uniqueness}`;

    console.log("SOJSAJ");

    // Create output media services asset to encode content into
    const outputAsset = await mediaServicesClient.assets.createOrUpdate(
      resourceGroupName,
      mediaServicesAccountName,
      outputAssetName,
      {}
    );

    console.log("SOJSAJ 2");

    if (outputAsset.name !== undefined) {
      // Submit the encoding job to the Transform's job queue
      let job = await submitJob(
        encodingTransformName,
        jobName,
        input,
        outputAsset.name
      );

      // Wait for job to finish encoding
      job = await waitForJobToFinish(encodingTransformName, jobName);

      if (!outputAsset.container) {
        throw Error("Failed to create container for asset.");
      }

      // Generate SAS URL for thumbnail image generated by encoding
      const thumbnailBlobName = "Thumbnail000001.jpg";
      const containerClient = blobServicesClient.getContainerClient(
        outputAsset.container
      );
      const blobClient = containerClient.getBlobClient(thumbnailBlobName);
      const storageSharedKeyCredentials = new StorageSharedKeyCredential(
        blobServicesAccountName,
        blobServicesAccountKey
      );

      const sasQueryParams = generateBlobSASQueryParameters(
        {
          containerName: outputAsset.container,
          blobName: thumbnailBlobName,
          permissions: BlobSASPermissions.parse("r"),
          startsOn: new Date(),
          expiresOn: new Date(99999999999999),
        },
        storageSharedKeyCredentials
      );

      const locator = await createStreamingLocator(
        outputAsset.name,
        locatorName
      );
      if (locator.name !== undefined) {
        const streamingUrls = await getStreamingUrls(locator.name);
        return {
          success: true,
          data: {
            streamingUrls,
            thumbnailUrl: `${blobClient.url}?${sasQueryParams}`,
          },
        };
      } else {
        throw new Error("Locator was not created or Locator.name is undefined");
      }
    } else {
      throw new Error("Output asset was unable to be created.");
    }
  } catch (error) {
    console.error(error);
    return { success: false, error: String(error) };
  }
};

const waitForJobToFinish = async (transformName: string, jobName: string) => {
  const timeout = new Date();
  timeout.setSeconds(timeout.getSeconds() + TIMEOUT_SECONDS);

  async function pollForJobStatus(): Promise<JobsGetResponse> {
    const job = await mediaServicesClient.jobs.get(
      resourceGroupName,
      mediaServicesAccountName,
      transformName,
      jobName
    );
    console.log(job.state);
    if (
      job.state == "Finished" ||
      job.state == "Error" ||
      job.state == "Canceled"
    ) {
      return job;
    } else if (new Date() > timeout) {
      console.log(
        `Job ${job.name} timed out. Please retry or check the source file.`
      );
      return job;
    } else {
      await setTimeoutPromise(SLEEP_INTERVAL, null);
      return pollForJobStatus();
    }
  }

  return await pollForJobStatus();
};

// Selects the JobInput type to use based on the value of inputFile or blobUrl.
// Set inputFile to null to create a Job input that sources from an HTTP URL path
// Creates a new input Asset and uploads the local file to it before returning a JobInputAsset object
// Returns a JobInputHttp object if inputFile is set to null, and the blobUrl is set to a valid URL
const getJobInputType = async ({
  blobUrl,
  uniqueness,
}: {
  blobUrl: string;
  uniqueness: string;
}): Promise<JobInputUnion> => {
  return factory.createJobInputHttp({
    files: [blobUrl],
  });
};

const submitJob = async (
  transformName: string,
  jobName: string,
  jobInput: JobInputUnion,
  outputAssetName: string
) => {
  if (outputAssetName == undefined) {
    throw new Error(
      "OutputAsset Name is not defined. Check creation of the output asset"
    );
  }
  const jobOutputs: JobOutputAsset[] = [
    factory.createJobOutputAsset({
      assetName: outputAssetName,
    }),
  ];

  return await mediaServicesClient.jobs.create(
    resourceGroupName,
    mediaServicesAccountName,
    transformName,
    jobName,
    {
      input: jobInput,
      outputs: jobOutputs,
    }
  );
};

const createStreamingLocator = async (
  assetName: string,
  locatorName: string
) => {
  const streamingLocator = {
    assetName: assetName,
    streamingPolicyName: "Predefined_ClearStreamingOnly", // no DRM or AES128 encryption protection on this asset. Clear means unencrypted.
  };

  const locator = await mediaServicesClient.streamingLocators.create(
    resourceGroupName,
    mediaServicesAccountName,
    locatorName,
    streamingLocator
  );

  return locator;
};

const getStreamingUrls = async (locatorName: string) => {
  // Make sure the streaming endpoint is in the "Running" state on account
  const streamingEndpoint = await mediaServicesClient.streamingEndpoints.get(
    resourceGroupName,
    mediaServicesAccountName,
    "default"
  );

  const paths = await mediaServicesClient.streamingLocators.listPaths(
    resourceGroupName,
    mediaServicesAccountName,
    locatorName
  );

  const streamingUrls: string[] = [];
  if (paths.streamingPaths) {
    paths.streamingPaths.forEach((path) => {
      path.paths?.forEach((formatPath) => {
        const manifestPath =
          "https://" + streamingEndpoint.hostName + formatPath;
        streamingUrls.push(manifestPath);
      });
    });
  }

  return streamingUrls;
};
