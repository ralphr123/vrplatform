import { DefaultAzureCredential } from "@azure/identity";
import {
  AzureMediaServices,
  JobOutputAsset,
  JobInputUnion,
  Job,
} from "@azure/arm-mediaservices";
import * as factory from "./transformFactory";
import { v4 as uuidv4 } from "uuid";
import * as util from "util";
import {
  BlobSASPermissions,
  BlobServiceClient,
  generateBlobSASQueryParameters,
  StorageSharedKeyCredential,
} from "@azure/storage-blob";

let mediaServicesClient: AzureMediaServices;
let blobServicesClient: BlobServiceClient;

const {
  AZURE_SUBSCRIPTION_ID: subscriptionId,
  AZURE_RESOURCE_GROUP: resourceGroupName,
  AZURE_MEDIA_SERVICES_ACCOUNT_NAME: mediaServicesAccountName,
  AZURE_STORAGE_ACCOUNT_NAME: blobServicesAccountName,
  AZURE_STORAGE_ACCOUNT_KEY: blobServicesAccountKey,
} = process.env;

const credential = new DefaultAzureCredential();
const storageUrl = `https://${mediaServicesAccountName}.blob.core.windows.net`;

// Args
const NAME_PREFIX = "stream";

export type EncodeVideoOnAzureFromBlobResp = {
  streamingUrls: string[];
  thumbnailUrl: string;
  mediaServicesAssetName: string;
};

export const encodeVideoOnAzureFromBlob = async (
  blobUrl: string
): Promise<{ job: Job; outputAssetName: string }> => {
  // Define the name to use for the encoding Transform that will be created
  const encodingTransformName = "ContentAwareEncoding";

  mediaServicesClient = new AzureMediaServices(credential, subscriptionId);

  const uniqueness = uuidv4();
  const input = await getJobInputType({ blobUrl });
  const outputAssetName = `${NAME_PREFIX}-output-${uniqueness}`;
  const jobName = `${NAME_PREFIX}-job-${uniqueness}`;

  // Create output media services asset to encode content into
  const outputAsset = await mediaServicesClient.assets.createOrUpdate(
    resourceGroupName,
    mediaServicesAccountName,
    outputAssetName,
    {}
  );

  if (outputAsset.name !== undefined) {
    // Submit the encoding job to the Transform's job queue
    let job = await submitJob(
      encodingTransformName,
      jobName,
      input,
      outputAsset.name
    );

    return { job, outputAssetName };
  } else {
    throw new Error("Output asset was unable to be created.");
  }
};

export const generateThumbnailAndStreamingUrls = async (
  outputAssetName: string
) => {
  const uniqueness = uuidv4();
  const locatorName = `locator${uniqueness}`;

  mediaServicesClient = new AzureMediaServices(credential, subscriptionId);
  blobServicesClient = new BlobServiceClient(storageUrl, credential);

  const outputAsset = await mediaServicesClient.assets.get(
    resourceGroupName,
    mediaServicesAccountName,
    outputAssetName
  );

  if (!outputAsset.container) {
    throw Error("Failed to find container for asset.");
  }

  // Generate SAS URL for thumbnail image generated by encoding
  const thumbnailBlobName = "Thumbnail000001.jpg";
  const containerClient = blobServicesClient.getContainerClient(
    outputAsset.container
  );
  const blobClient = containerClient.getBlobClient(thumbnailBlobName);
  const storageSharedKeyCredentials = new StorageSharedKeyCredential(
    blobServicesAccountName,
    blobServicesAccountKey
  );

  const sasQueryParams = generateBlobSASQueryParameters(
    {
      containerName: outputAsset.container,
      blobName: thumbnailBlobName,
      permissions: BlobSASPermissions.parse("r"),
      startsOn: new Date(),
      expiresOn: new Date(99999999999999),
    },
    storageSharedKeyCredentials
  );

  const locator = await createStreamingLocator(outputAssetName, locatorName);

  if (!locator.name) {
    throw new Error("Locator was not created or Locator.name is undefined");
  }

  const streamingUrls = await getStreamingUrls(locator.name);
  return {
    streamingUrls,
    thumbnailUrl: `${blobClient.url}?${sasQueryParams}`,
  };
};

// Creates a new input Asset and uploads the local file to it before returning a JobInputAsset object
const getJobInputType = async ({
  blobUrl,
}: {
  blobUrl: string;
}): Promise<JobInputUnion> => {
  return factory.createJobInputHttp({
    files: [blobUrl],
  });
};

const submitJob = async (
  transformName: string,
  jobName: string,
  jobInput: JobInputUnion,
  outputAssetName: string
) => {
  if (outputAssetName == undefined) {
    throw new Error(
      "OutputAsset Name is not defined. Check creation of the output asset"
    );
  }
  const jobOutputs: JobOutputAsset[] = [
    factory.createJobOutputAsset({
      assetName: outputAssetName,
    }),
  ];

  return await mediaServicesClient.jobs.create(
    resourceGroupName,
    mediaServicesAccountName,
    transformName,
    jobName,
    {
      input: jobInput,
      outputs: jobOutputs,
    }
  );
};

const createStreamingLocator = async (
  assetName: string,
  locatorName: string
) => {
  const streamingLocator = {
    assetName: assetName,
    // no DRM or AES128 encryption protection on this asset. Clear means unencrypted.
    streamingPolicyName: "Predefined_ClearStreamingOnly",
  };

  const locator = await mediaServicesClient.streamingLocators.create(
    resourceGroupName,
    mediaServicesAccountName,
    locatorName,
    streamingLocator
  );

  return locator;
};

const getStreamingUrls = async (locatorName: string) => {
  const streamingEndpoint = await mediaServicesClient.streamingEndpoints.get(
    resourceGroupName,
    mediaServicesAccountName,
    "default"
  );

  const paths = await mediaServicesClient.streamingLocators.listPaths(
    resourceGroupName,
    mediaServicesAccountName,
    locatorName
  );

  const streamingUrls: string[] = [];
  if (paths.streamingPaths) {
    paths.streamingPaths.forEach((path) => {
      path.paths?.forEach((formatPath) => {
        const manifestPath =
          "https://" + streamingEndpoint.hostName + formatPath;
        streamingUrls.push(manifestPath);
      });
    });
  }

  return streamingUrls;
};
